#!/usr/bin/env ruby

Signal.trap("INT") { exit 1 }

#---

require 'coral_core'

#---

logger = Coral.logger
logger.info("`coral` invoked: #{ARGV.inspect}")

#---

$stdout.sync = true
$stderr.sync = true

#---

begin
  logger.debug("Beginning execution run")
  
  arg_components = Coral::Util::CLI::Parser.split(ARGV, 'coral <action> [ <arg> ... ]')
  main_command   = arg_components.shift
  sub_command    = arg_components.shift
  sub_args       = arg_components
  
  loaded_actions = Coral::Plugin.loaded_plugins(:action)
  
  if main_command.processed && sub_command
    logger.debug("Running coral action #{sub_command} with #{sub_args.inspect}")
    
    exit_status = Coral.action(sub_command, sub_args).execute
  else
    puts I18n.t('coral.core.exec.help.usage') + ': ' + main_command.help + "\n"
    puts I18n.t('coral.core.exec.help.header') + ":\n\n"
    
    loaded_actions.each do |provider, action|
      puts sprintf("   %-10s : %s\n", 
        "<#{provider}>", 
        Coral.action(provider, [ '-h' ], true).help
      )
    end
    
    puts "\n" + I18n.t('coral.core.exec.help.footer') + "\n\n"   
    exit_status = Coral.code.help_wanted  
  end 
  
rescue Exception => error
  logger.error("Coral experienced an error! Details:")
  logger.error(error.inspect)
  logger.error(error.message)
  logger.error(Coral::Util::Data.to_yaml(error.backtrace))

  Coral.ui.error(error.message, { :prefix => false }) if error.message
  
  exit_status = error.status_code if error.respond_to?(:status_code)
end

exit_status = Coral.code.unknown_status unless exit_status.is_a?(Integer)
exit(exit_status)
