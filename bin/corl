#!/usr/bin/env ruby

Signal.trap("INT") { exit 1 }

#---

require 'corl_core'

logger = CORL.logger
logger.info("`corl` invoked: #{ARGV.inspect}")

#---

$stdout.sync = true
$stderr.sync = true

#---

begin
  logger.debug("Beginning execution run")
  
  arg_components = CORL::Util::CLI::Parser.split(ARGV, 'corl <action> [ <arg> ... ]')
  main_command   = arg_components.shift
  sub_command    = arg_components.shift
  sub_args       = arg_components
  
  if main_command.processed && sub_command
    exit_status = CORL.action_cli(sub_command, sub_args)
  else
    puts I18n.t('corl.core.exec.help.usage') + ': ' + main_command.help + "\n"
    puts I18n.t('corl.core.exec.help.header') + ":\n\n"
    
    CORL::Manager.connection.loaded_plugins(:action).each do |provider, action|
      puts sprintf("   %-10s : %s\n", 
        "<#{provider}>", 
        CORL.action(provider, { :settings => {}, :quiet => true }).help
      )
    end
    
    puts "\n" + I18n.t('corl.core.exec.help.footer') + "\n\n"   
    exit_status = CORL.code.help_wanted  
  end 
  
rescue Exception => error
  logger.error("Corl executable experienced an error:")
  logger.error(error.inspect)
  logger.error(error.message)
  logger.error(CORL::Util::Data.to_yaml(error.backtrace))

  CORL.ui.error(error.message, { :prefix => false }) if error.message
  
  exit_status = error.status_code if error.respond_to?(:status_code)
end

exit(exit_status)
